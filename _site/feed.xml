<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-07-20T20:10:06-05:00</updated><id>/feed.xml</id><title type="html">Jason Hong</title><subtitle>:)
</subtitle><author><name>Jason Hong</name><email>jason@jasonhong.xyz</email></author><entry><title type="html">Jekyll, Docker Compose, and CircleCI</title><link href="/blog/2022/07/01/on-jekyll-jenkins-docker.html" rel="alternate" type="text/html" title="Jekyll, Docker Compose, and CircleCI" /><published>2022-07-01T19:38:29-05:00</published><updated>2022-07-01T19:38:29-05:00</updated><id>/blog/2022/07/01/on-jekyll-jenkins-docker</id><content type="html" xml:base="/blog/2022/07/01/on-jekyll-jenkins-docker.html"><![CDATA[<p>I need an easier, faster, better way to maintain my site.</p>

<h3 id="the-before">The “Before”</h3>

<p>This site was originally stood up November 2020 as just a HTML/CSS template on
a tiny VPS. It took the better part of a weekend to get the domain, nginx, and
LetsEncrypt configuration all set up (mostly because I had no idea what I was
doing). Aside from the occassional updates and reboots, the site remained
largely unchanged for the duration of its tenure.</p>

<p>I was pretty proud of it, sure, but as time went on, a few things started to
bother me. My lack of familiarity with HTML/CSS meant there was no good avenue
for me to write (which I wanted to do) without first learning some front-end.
The manual configuration meant that if, for whatever reason, my site were to
break, it could/would require quite a bit of time and effort to set up <em>all
over again</em>.</p>

<h3 id="the-fix">The “Fix”</h3>

<p>Some choices I made and why:</p>
<ul>
  <li><a href="https://jekyllrb.com/docs/home">Jekyll</a>: I wanted a site that was dead simple to edit, so a
static-site generator was a natural choice. I also like Markdown and LaTeX.</li>
  <li><a href="https://docs.docker.com/">Docker</a>/<a href="https://docs.docker.com/compose/">Compose</a>: I wanted something that was easy to
deploy, and was pretty portable.</li>
  <li><a href="https://circleci.com/">Circle CI</a>: I wanted something that I can <code class="language-plaintext highlighter-rouge">git push</code>, and
everything is deployed automatically. I initially set up a Jenkins container
on the same VPS – it worked, but I found Circle CI to be easier to use.</li>
  <li><a href="https://updown.io/">Updown.io</a>: Simple uptime monitoring. I want a status page for all
my subdomains at <code class="language-plaintext highlighter-rouge">status.jasonhong.xyz</code>.</li>
</ul>

<p>With these tools, I shouldn’t ever have to start <em>completely</em> from scratch
again.</p>

<h3 id="the-workstream">The Workstream</h3>

<p>The workflow can be summarized as follows – create Docker containers for my
blog, reverse proxy, and any projects, and stand them up in a hot-swappable,
automated fashion using compose.</p>

<p>The Dockerfile for my blog:</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nginx</span>
<span class="k">COPY</span><span class="s"> _site /usr/share/nginx/html</span>
</code></pre></div></div>
<p>Straightforward. This pulls the nginx image and copies the generated HTML files
from Jekyll into the correct folder.</p>

<p>The compose entry:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">blog</span><span class="pi">:</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">jasonhongxyz/blog</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">traefik.enable=true"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">traefik.http.routers.blog.rule=Host(`jasonhong.xyz`)</span><span class="nv"> </span><span class="s">||</span><span class="nv"> </span><span class="s">Host(`www.jasonhong.xyz`)"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">traefik.http.routers.blog.entrypoints=websecure"</span>
        <span class="pi">-</span> <span class="s2">"</span><span class="s">traefik.http.routers.blog.tls.certresolver=myresolver"</span>
      <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>I used a <a href="https://doc.traefik.io/traefik/">Traefik Proxy</a> container as my reverse proxy service.
The configuration for Traefik can be done through its compose entry – I used
the following to register the domains, and setup LetsEncrypt certs.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">reverse-proxy</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">traefik:latest</span>
    <span class="c1"># Enables the web UI and tells Traefik to listen to docker</span>
    <span class="na">command</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--api.insecure=true"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--providers.docker=true"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--providers.docker.exposedbydefault=false"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--entrypoints.web.address=:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--entrypoints.websecure.address=:443"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--entrypoints.web.http.redirections.entrypoint.to=websecure"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--entrypoints.web.http.redirections.entrypoint.scheme=https"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--certificatesresolvers.myresolver.acme.httpchallenge=true"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web"</span>
      <span class="c1"># Comment to use production LetsEncrypt environment</span>
      <span class="c1">#- "--certificatesresolvers.myresolver.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--certificatesresolvers.myresolver.acme.email=jasonhong0810@gmail.com"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json"</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
      <span class="c1"># The Web UI (enabled by --api.insecure=true)</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:8080"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">./letsencrypt:/letsencrypt"</span>
      <span class="c1"># So that Traefik can listen to the Docker events</span>
      <span class="pi">-</span> <span class="s">/var/run/docker.sock:/var/run/docker.sock</span>
</code></pre></div></div>
<p>Traefik <a href="https://doc.traefik.io/traefik/https/acme/#automatic-renewals">manages</a> the expiry date of ACME certificates – the
default is 90 days with renewals at 30 days before expiry.</p>

<h4 id="deployment">Deployment</h4>

<p>Running <code class="language-plaintext highlighter-rouge">jekyll build</code> creates a <code class="language-plaintext highlighter-rouge">_site</code> directory with the generated HTML.
This component could be done automatically with CircleCI, but I don’t mind
generating the HTML myself to keep a git tracked copy. Maybe one day when I
have a bit more time I can automate this part as well.</p>

<p>CircleCI is triggered on every <code class="language-plaintext highlighter-rouge">git push</code> to the repository. The pipeline first
clones into the directory, and rebuilds the Docker image using the <code class="language-plaintext highlighter-rouge">_site</code>
files and <code class="language-plaintext highlighter-rouge">Dockerfile-blog</code>. That image is pushed to my Docker Hub account.</p>

<p>Then, the pipeline SSH’s into my Linode VPS, pulls the latest <code class="language-plaintext highlighter-rouge">blog</code> image from
Docker Hub, and reruns <code class="language-plaintext highlighter-rouge">docker compose up -d</code>.</p>

<p>And just like that… my site is updated. :)</p>

<p><img src="/assets/nicolas_cage_party.gif" alt="nicolas_cage_party" width="32" /></p>]]></content><author><name>Jason Hong</name><email>jason@jasonhong.xyz</email></author><category term="blog" /><summary type="html"><![CDATA[I need an easier, faster, better way to maintain my site.]]></summary></entry><entry><title type="html">Mini-Haskell</title><link href="/projects/2022/06/01/test-project.html" rel="alternate" type="text/html" title="Mini-Haskell" /><published>2022-06-01T19:38:29-05:00</published><updated>2022-06-01T19:38:29-05:00</updated><id>/projects/2022/06/01/test-project</id><content type="html" xml:base="/projects/2022/06/01/test-project.html"><![CDATA[<p>A Haskell-like Functional Programming Language</p>]]></content><author><name>Jason Hong</name><email>jason@jasonhong.xyz</email></author><category term="projects" /><summary type="html"><![CDATA[A Haskell-like Functional Programming Language]]></summary></entry></feed>